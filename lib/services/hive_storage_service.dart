import 'dart:io';
import 'dart:convert';
import 'package:hive/hive.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';
import '../models/cloud_node.dart';
import '../models/cloud_account.dart';
import '../models/virtual_raid_upload_strategy.dart';

class HiveStorageService {
  static final HiveStorageService instance = HiveStorageService._init();
  static bool _initialized = false;
  
  // Hive boxes
  late Box<CloudNode> _nodesBox;
  late Box<CloudAccount> _accountsBox;
  late Box<String> _virtualLinksBox; // Maps virtual_node_id -> account_id (comma-separated)
  late Box<String> _syncConfigsBox; // Sync configurations
  late Box<String> _settingsBox; // App settings (including task limits)
  
  HiveStorageService._init();

  /// Initialize Hive and open all boxes
  Future<void> initialize() async {
    if (_initialized) return;
    
    // Get the Documents directory
    final Directory documentsDirectory = await getApplicationDocumentsDirectory();
    
    // Create "Cloud Nexus" folder inside Documents
    final Directory cloudNexusDirectory = Directory(path.join(documentsDirectory.path, 'Cloud Nexus'));
    
    // Ensure the directory exists
    if (!await cloudNexusDirectory.exists()) {
      await cloudNexusDirectory.create(recursive: true);
    }
    
    // Initialize Hive with the custom directory
    Hive.init(cloudNexusDirectory.path);
    
    // Register adapters (they will be generated by build_runner)
    if (!Hive.isAdapterRegistered(0)) {
      Hive.registerAdapter(CloudNodeAdapter());
    }
    if (!Hive.isAdapterRegistered(1)) {
      Hive.registerAdapter(CloudAccountAdapter());
    }
    
    
    // Open boxes
    _nodesBox = await Hive.openBox<CloudNode>('nodes');
    _accountsBox = await Hive.openBox<CloudAccount>('accounts');
    _virtualLinksBox = await Hive.openBox<String>('virtual_links');
    _syncConfigsBox = await Hive.openBox<String>('sync_configs');
    _settingsBox = await Hive.openBox<String>('settings');
    
    _initialized = true;
  }

  /// Check if Hive is initialized
  bool get isInitialized => _initialized;

  /// Close all boxes
  Future<void> close() async {
    await _nodesBox.close();
    await _accountsBox.close();
    await _virtualLinksBox.close();
    await _syncConfigsBox.close();
    await _settingsBox.close();
    _initialized = false;
  }
  
  /// Clear all data (useful for testing)
  Future<void> clearAll() async {
    await _nodesBox.clear();
    await _accountsBox.clear();
    await _virtualLinksBox.clear();
    await _syncConfigsBox.clear();
    await _settingsBox.clear();
  }

  // --- ACCOUNT OPERATIONS ---

  Future<void> createAccount(CloudAccount account) async {
    // Auto-assign orderIndex if not set (append to end)
    if (account.orderIndex == 0) {
      final allAccounts = _accountsBox.values.toList();
      final maxIndex = allAccounts.isEmpty
          ? -1
          : allAccounts.map((a) => a.orderIndex).reduce((a, b) => a > b ? a : b);
      account = CloudAccount(
        id: account.id,
        provider: account.provider,
        name: account.name,
        email: account.email,
        accessToken: account.accessToken,
        refreshToken: account.refreshToken,
        tokenExpiry: account.tokenExpiry,
        credentials: account.credentials,
        encryptUploads: account.encryptUploads,
        orderIndex: maxIndex + 1,
      );
    }
    await _accountsBox.put(account.id, account);
  }

  Future<List<CloudAccount>> getAccounts() async {
    final accounts = _accountsBox.values.toList();
    // Sort by orderIndex
    accounts.sort((a, b) => a.orderIndex.compareTo(b.orderIndex));
    return accounts;
  }

  Future<CloudAccount?> getAccount(String accountId) async {
    return _accountsBox.get(accountId);
  }

  /// Update encryption setting for an account
  Future<void> updateAccountEncryption(String accountId, bool encryptUploads) async {
    final account = await getAccount(accountId);
    if (account != null) {
      final updatedAccount = CloudAccount(
        id: account.id,
        provider: account.provider,
        name: account.name,
        email: account.email,
        accessToken: account.accessToken,
        refreshToken: account.refreshToken,
        tokenExpiry: account.tokenExpiry,
        credentials: account.credentials,
        encryptUploads: encryptUploads,
        orderIndex: account.orderIndex,
      );
      await _accountsBox.put(accountId, updatedAccount);
    }
  }

  /// Reorder accounts by updating their orderIndex values
  /// Returns the updated ordered list of accounts
  Future<List<CloudAccount>> reorderAccounts(
    List<String> accountIds,
  ) async {
    final accounts = await getAccounts();
    
    // Build a map of current account data
    final accountMap = {for (var account in accounts) account.id: account};
    
    // Update orderIndex for each account based on new order
    final reorderedAccounts = <CloudAccount>[];
    for (int i = 0; i < accountIds.length; i++) {
      final accountId = accountIds[i];
      final existingAccount = accountMap[accountId];
      if (existingAccount != null) {
        final updatedAccount = CloudAccount(
          id: existingAccount.id,
          provider: existingAccount.provider,
          name: existingAccount.name,
          email: existingAccount.email,
          accessToken: existingAccount.accessToken,
          refreshToken: existingAccount.refreshToken,
          tokenExpiry: existingAccount.tokenExpiry,
          credentials: existingAccount.credentials,
          encryptUploads: existingAccount.encryptUploads,
          orderIndex: i,
        );
        reorderedAccounts.add(updatedAccount);
        await _accountsBox.put(accountId, updatedAccount);
      }
    }
    
    // Update any remaining accounts that weren't in the reorder list
    // (in case of partial reorders)
    final maxIndex = accountIds.length;
    for (final account in accounts) {
      if (!accountIds.contains(account.id)) {
        final updatedAccount = CloudAccount(
          id: account.id,
          provider: account.provider,
          name: account.name,
          email: account.email,
          accessToken: account.accessToken,
          refreshToken: account.refreshToken,
          tokenExpiry: account.tokenExpiry,
          credentials: account.credentials,
          encryptUploads: account.encryptUploads,
          orderIndex: maxIndex,
        );
        await _accountsBox.put(account.id, updatedAccount);
      }
    }
    
    return await getAccounts();
  }

  // --- NODE OPERATIONS ---

  Future<void> createNode(CloudNode node) async {
    await _nodesBox.put(node.id, node);
  }

  /// Batch create nodes for better performance
  Future<void> batchCreateNodes(List<CloudNode> nodes) async {
    if (nodes.isEmpty) return;
    
    final Map<String, CloudNode> nodeMap = {};
    for (final node in nodes) {
      nodeMap[node.id] = node;
    }
    
    await _nodesBox.putAll(nodeMap);
  }

  Future<List<CloudNode>> getChildren(String? parentId) async {
    final children = _nodesBox.values.where((node) => node.parentId == parentId).toList();
    
    // Sort: folders first, then alphabetical
    children.sort((a, b) {
      if (a.isFolder != b.isFolder) {
        return a.isFolder ? -1 : 1; // Folders first
      }
      return a.name.toLowerCase().compareTo(b.name.toLowerCase()); // Alphabetical
    });
    
    return children;
  }

  Future<void> deleteNode(String nodeId) async {
    await _nodesBox.delete(nodeId);
  }

  /// Delete an account from storage
  Future<void> deleteAccount(String accountId) async {
    await _accountsBox.delete(accountId);
  }

  /// Batch delete nodes for better performance
  Future<void> batchDeleteNodes(List<String> nodeIds) async {
    if (nodeIds.isEmpty) return;
    await _nodesBox.deleteAll(nodeIds);
  }

  /// Optimized query for getting nodes with pagination
  Future<List<CloudNode>> getChildrenPaginated(String? parentId, {int limit = 50, int offset = 0}) async {
    final children = _nodesBox.values.where((node) => node.parentId == parentId).toList();
    
    // Sort: folders first, then alphabetical
    children.sort((a, b) {
      if (a.isFolder != b.isFolder) {
        return a.isFolder ? -1 : 1;
      }
      return a.name.toLowerCase().compareTo(b.name.toLowerCase());
    });
    
    // Apply pagination
    final start = offset;
    final end = (start + limit).clamp(0, children.length);
    
    if (start >= children.length) return [];
    
    return children.sublist(start, end);
  }

  /// Search nodes by name with performance optimization
  Future<List<CloudNode>> searchNodes(String query, {String? parentId, int limit = 100}) async {
    final lowerQuery = query.toLowerCase();
    final results = _nodesBox.values.where((node) {
      final matchesName = node.name.toLowerCase().contains(lowerQuery);
      final matchesParent = parentId == null || node.parentId == parentId;
      return matchesName && matchesParent;
    }).toList();
    
    // Sort: folders first, then alphabetical
    results.sort((a, b) {
      if (a.isFolder != b.isFolder) {
        return a.isFolder ? -1 : 1;
      }
      return a.name.toLowerCase().compareTo(b.name.toLowerCase());
    });
    
    // Apply limit
    return results.take(limit).toList();
  }

  /// Get node count for pagination info
  Future<int> getChildrenCount(String? parentId) async {
    return _nodesBox.values.where((node) => node.parentId == parentId).length;
  }

  // --- VIRTUAL DRIVE OPERATIONS ---

  /// Link an account to a virtual drive
  Future<void> linkAccountToVirtualDrive(String virtualNodeId, String accountId) async {
    final existingLinks = _virtualLinksBox.get(virtualNodeId) ?? '';
    final accountIds = existingLinks.isEmpty ? [] : existingLinks.split(',');
    
    if (!accountIds.contains(accountId)) {
      accountIds.add(accountId);
      await _virtualLinksBox.put(virtualNodeId, accountIds.join(','));
    }
  }

  /// Get all accounts linked to a virtual drive
  Future<List<String>> getLinkedAccounts(String virtualNodeId) async {
    final links = _virtualLinksBox.get(virtualNodeId);
    if (links == null || links.isEmpty) return [];
    return links.split(',');
  }

  /// Unlink an account from a virtual drive
  Future<void> unlinkAccountFromVirtualDrive(String virtualNodeId, String accountId) async {
    final existingLinks = _virtualLinksBox.get(virtualNodeId) ?? '';
    final accountIds = existingLinks.isEmpty ? [] : existingLinks.split(',');
    
    accountIds.remove(accountId);
    
    if (accountIds.isEmpty) {
      await _virtualLinksBox.delete(virtualNodeId);
    } else {
      await _virtualLinksBox.put(virtualNodeId, accountIds.join(','));
    }
  }

  /// Check if an account is linked to any virtual drive
  /// Returns a list of virtual drive names that use this account, or empty list if not linked
  Future<List<String>> getVirtualDrivesForAccount(String accountId) async {
    final linkedVirtualDrives = <String>[];
    
    // Get all nodes to find virtual drives
    final allNodes = _nodesBox.values.toList();
    final virtualDrives = allNodes.where((node) =>
      node.provider == 'virtual' && node.parentId == null
    ).toList();
    
    // Check each virtual drive to see if it contains this account
    for (final virtualDrive in virtualDrives) {
      final linkedAccounts = await getLinkedAccounts(virtualDrive.id);
      if (linkedAccounts.contains(accountId)) {
        linkedVirtualDrives.add(virtualDrive.name);
      }
    }
    
    return linkedVirtualDrives;
  }

  // --- MIGRATION HELPERS ---

  /// Get all nodes for migration purposes
  List<CloudNode> getAllNodes() {
    return _nodesBox.values.toList();
  }

  /// Get all accounts for migration purposes
  List<CloudAccount> getAllAccounts() {
    return _accountsBox.values.toList();
  }

  /// Get all virtual links for migration purposes
  Map<String, List<String>> getAllVirtualLinks() {
    final Map<String, List<String>> links = {};
    for (final key in _virtualLinksBox.keys) {
      final value = _virtualLinksBox.get(key);
      if (value != null) {
        links[key] = value.split(',');
      }
    }
    return links;
  }

  // --- PERFORMANCE MONITORING ---

  /// Get storage statistics
  Map<String, dynamic> getStorageStats() {
    return {
      'nodesCount': _nodesBox.length,
      'accountsCount': _accountsBox.length,
      'virtualLinksCount': _virtualLinksBox.length,
      'isInitialized': _initialized,
    };
  }

  /// Compact storage (optimize Hive files)
  Future<void> compact() async {
    await _nodesBox.compact();
    await _accountsBox.compact();
    await _virtualLinksBox.compact();
    await _syncConfigsBox.compact();
    await _settingsBox.compact();
  }
  
  // --- SYNC CONFIG OPERATIONS ---
  
  /// Get all sync configurations
  Future<List<Map<String, dynamic>>> getSyncConfigs() async {
    return _syncConfigsBox.values.map((e) => Map<String, dynamic>.from(json.decode(e))).toList();
  }
  
  /// Save a sync configuration
  Future<void> saveSyncConfig(Map<String, dynamic> config) async {
    final id = config['id'] as String;
    await _syncConfigsBox.put(id, json.encode(config));
  }
  
  /// Delete a sync configuration
  Future<void> deleteSyncConfig(String configId) async {
    await _syncConfigsBox.delete(configId);
  }
  
  // --- TASK LIMITS SETTINGS ---
  
  /// Get task limits from storage
  Future<Map<String, int>?> getTaskLimits() async {
    final limitsJson = _settingsBox.get('task_limits');
    if (limitsJson == null) {
      return null;
    }
    
    try {
      final Map<String, dynamic> limitsMap = json.decode(limitsJson);
      return {
        'maxConcurrentTasks': limitsMap['maxConcurrentTasks'] as int? ?? 15,
        'maxConcurrentTransfersPerAccount': limitsMap['maxConcurrentTransfersPerAccount'] as int? ?? 3,
        'maxConcurrentTransfersSameAccount': limitsMap['maxConcurrentTransfersSameAccount'] as int? ?? 5,
      };
    } catch (e) {
      return null;
    }
  }
  
  /// Save task limits to storage
  Future<void> saveTaskLimits({
    required int maxConcurrentTasks,
    required int maxConcurrentTransfersPerAccount,
    required int maxConcurrentTransfersSameAccount,
  }) async {
    final limitsMap = {
      'maxConcurrentTasks': maxConcurrentTasks,
      'maxConcurrentTransfersPerAccount': maxConcurrentTransfersPerAccount,
      'maxConcurrentTransfersSameAccount': maxConcurrentTransfersSameAccount,
    };
    
    await _settingsBox.put('task_limits', json.encode(limitsMap));
  }
  
  // --- VIRTUAL RAID UPLOAD STRATEGY SETTINGS ---
  
  /// Get the current upload strategy for Virtual RAID drives
  /// Returns the saved strategy or defaults to manual if not set
  Future<VirtualRaidUploadStrategy> getUploadStrategy() async {
    final strategyIndex = _settingsBox.get('virtual_raid_upload_strategy');
    if (strategyIndex == null) {
      // Default to manual if not set
      return VirtualRaidUploadStrategy.manual;
    }
    
    try {
      final index = int.parse(strategyIndex);
      if (index >= 0 && index < VirtualRaidUploadStrategy.values.length) {
        return VirtualRaidUploadStrategy.values[index];
      }
    } catch (e) {
    }
    
    // Default to manual if parsing fails
    return VirtualRaidUploadStrategy.manual;
  }
  
  /// Save the upload strategy for Virtual RAID drives
  Future<void> setUploadStrategy(VirtualRaidUploadStrategy strategy) async {
    final strategyIndex = strategy.index;
    await _settingsBox.put('virtual_raid_upload_strategy', strategyIndex.toString());
  }
  
  // --- SEARCH RESULTS LIMIT SETTINGS ---
  
  /// Get the saved search results limit
  /// Returns the saved limit or default to 50 if not set
  Future<int> getSearchResultsLimit() async {
    final limitStr = _settingsBox.get('search_results_limit');
    if (limitStr == null) {
      return 50; // Default value
    }
    
    try {
      return int.parse(limitStr);
    } catch (e) {
      return 50; // Default value on error
    }
  }
  
  /// Save the search results limit
  Future<void> setSearchResultsLimit(int limit) async {
    await _settingsBox.put('search_results_limit', limit.toString());
  }
  
  /// Get whether custom limit was selected
  Future<bool> isCustomLimitSelected() async {
    final selected = _settingsBox.get('search_custom_limit_selected');
    return selected == 'true';
  }
  
  /// Save whether custom limit was selected
  Future<void> setCustomLimitSelected(bool selected) async {
    await _settingsBox.put('search_custom_limit_selected', selected.toString());
  }
  
}